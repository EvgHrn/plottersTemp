/**
  ******************************************************************************
  * File Name          : main.c
  * Description        : Main program body
  ******************************************************************************
  *
  * COPYRIGHT(c) 2016 STMicroelectronics
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */
/* Includes ------------------------------------------------------------------*/


/* USER CODE BEGIN Includes */

#include "main.h"

/* USER CODE END Includes */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
/* Private variables ---------------------------------------------------------*/

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
void MX_NVIC_Init(void);

/* USER CODE BEGIN PFP */
/* Private function prototypes -----------------------------------------------*/



/* USER CODE END PFP */

/* USER CODE BEGIN 0 */

//------------  собственные переменные  -----------------------------------

uint16_t S0_RX_BASE;      //  начальный адрес памяти, выделенной в RX буфере для Сокета0
uint16_t S0_RX_MASK;      // РАЗМЕР RX  буфера Сокета0
uint16_t S0_RX_OFFSET;    // указатель на начало принятого блока данных в RX буфере 
uint16_t S0_RX_Start_Addr; // ФИЗИЧЕСКИЙ  адрес начала принтого блока данных в RX буфере 
uint16_t S0_RX_RSR ;       //  РАЗМЕР принятого от Клиента блока данных
uint16_t S0_TX_BASE;    // начальный адрес памяти, выделенной в ТX буфере для Сокета0
uint16_t S0_TX_MASK;     // РАЗМЕР ТX  буфера Сокета0
uint16_t S0_TX_OFFSET ;  
												 // указатель на начальный  адрес в памяти  ТХ буфера, куда следует записать блок 
												 // данных для передачи Клиенту  
uint16_t S0_TX_Start_Addr;  
												 // ФИЗИЧЕСКИЙ  Начальный адрес в памяти ТХ буфера, куда следует записать 
												 // блок  данных для передачи Клиенту  
uint16_t S0_TX_End_Addr; 
												 // указатель на Конечный адрес в памяти ТХ буфера, до которого W5100
												 //  должен дойти при считывании данных отсылаемых Клиенту

// --- строки символов для использования как HTTP  заголовки и «веб-странички»
// * размер  массива [222] взят с потолка и с запасом. Потом программа  расчитает  реальную длину данных
// ** CONST – чтобы  расположить строку в ПРОГРАММНОЙ памяти ( где места полно)
uint32_t main_count = 0;

const char ERROR404[222] = { "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Lenght: 39\r\n\r\n<HTML><CENTER>ERROR 404</CENTER></HTML>"};
// символы для  создания  странички «ошибка 404”

int try=0;  //  временно, для отладки. Номер обращения браузера –к серверу




/* USER CODE END 0 */

int main(void)
{

  /* USER CODE BEGIN 1 */
	
	
	

  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* Configure the system clock */
  SystemClock_Config();

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USART3_UART_Init();
  MX_SPI1_Init();

  /* Initialize interrupts */
  MX_NVIC_Init();

  /* USER CODE BEGIN 2 */
	
	uint32_t count_temp = 0;
	char uart_data[20] = "";
	
	Init();   // инициализация  W5100  и системы ( сервера)
	
	OpenSocket0:
	
	//ooooooooooooooooooo ОТКРЫВАЕМ СОКЕТ 0 oooooooooooooooooooooooo
	if ( ! Open_Socket0() ) goto OpenSocket0; // цикл пока Сокет не откроется
	
	//ooooooooooooooooo  СЛУШАЕМ СОКЕТ  ooooooooooooooooooooooooo
	if ( Listen_Socket0() == 0 ) goto OpenSocket0; //если  сокет не «прослушивается» - уходим заново на открытие сокета
	
	//oooooooooooooo Соединение УСТАНОВЛЕНО ? oooooooooooooo

	CheckConnection:

  if (Socket0_Connection_Established() == 0 ) goto CheckConnection;
	// цикл пока соединение не установится ( тоесть пока не придет запрос от браузера)
  char messsage_check[] = "Connection Established... \r\n";
	uprintf(messsage_check);
	// для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ             

	//ooooooo( соединение уже установлено)  в принятых пакетах -  ДАННЫЕ? oooooo                                 
  if  ( Socket0_Received_Data_Size() == 0 ) {
		char messsage_check2[] = "\r\n> (Zero) Received Data size is: %Lu (bytes) \r\n";
		uprintf(messsage_check2);
		// для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
		goto CheckFIN;   // раз ДАННЫХ нет о и передавать в отет нечего
															// поэтому сразу идем на проверку флагаFIN
  } // раз данных нет ( размер=0) то уходим на этап проверки закрытия соединения
   else    
   {
		 
		uprintf("(NonZero) Received Data size is: %Lu (bytes) \r\n");
                   // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
   }
  
	// oooooooooo ( Данные в пакете есть) Процесс обработки*   ooooooooooooooo 

	//на самом деле просто  выводит на терминал принятые данные
	// после отладки этот кусок можно удалить
	//Socket0_Received_Data_Reading();   
	// для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

	// oooooooooooooo  Процесс ПЕРЕДАЧИ данных  ooooooooooooooooooooooooooooooo
	// тоесть отсылаем браузеру HTTP заголовок и HTML страничку
 
	if ( Socket0_Received_Request_is_index_html() ==  1)   Socket0_Send_index_html ();
   // если  клиент запрашивает "index.html"  то остылаем ему  index.html

	else  Socket0_Send_404_error (); 
   //  если запрос любого другого файла  то  отсылаем  «страничку»  «ошибка 404»
  
	//ooooooooooo    Получен флаг  FIN ? ooooooooooooooooooooooooooo
	//  тоесть проверка требует ли  Клиент разрыва соединения

	CheckFIN:

	if ( Socket0_FIN_Received() == 1) goto  CloseConnection; //если FIN  пришел  - то  уходим закрывать СОКЕТ0

	//ooooooooooo    Разрыв соединения   ooooooooooooooooooooooo 
  Socket0_Disconnect();    //разрыв СОЕДИНЕНИЯ Сокета0

	//ooooooooooo   Сокет ЗАКРЫТ ?    ooooooooooooooooooooooooooooooo
	if (Socket0_Closed() == 1 )  goto CloseConnection; // если Сокет закрыт – уходим закрывать Соединение

	//ooooooooooo   Не наступил ли тайм-аут по соединению  ?  ooooooooooooooooooo
	if ( Socket0_Connection_Timeout() == 1)  goto CloseConnection;
	//сокет не закрыт, но наступил тайм-аут, – уходим закрывать сокет

	CloseConnection:

	//ooooooooooo   Закрываем Сокет    ooooooooooooooooooooooooooooooooooo
  Socket0_Closing();  
	//oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

	goto OpenSocket0;
	// соединение с Клиентом отработано, цикл завершился.
	//  Уходим в начало и запускаем все по новой ( ждем новых запросов «веб-сайта» )
	

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
  /* USER CODE END WHILE */

  /* USER CODE BEGIN 3 */
		

				
				
		

  }
  /* USER CODE END 3 */

}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL8;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);

  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
}

/** NVIC Configuration
*/
void MX_NVIC_Init(void)
{
  /* EXTI1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(EXTI1_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI1_IRQn);
  /* SPI1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SPI1_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(SPI1_IRQn);
  /* USART3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(USART3_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(USART3_IRQn);
}

/* USER CODE BEGIN 4 */

void uprintf (char * str){
	HAL_UART_Transmit (&huart3, (uint8_t *)str, 100, 100);
}


void Init(void) {
	output_low(RESET); //генерируем «Сброс» для Ардуиновского Ethernet  шилда 
	HAL_Delay(5);
	output_high(RESET);
	//output_low(SCK);  //готовим пины (уровни) для  SPI
	output_high(SS) ;

	//программный сброс чипа W5100.
	SetW5100register(MR, 0x80);   // пишем код  RST  в W5100 Mode Register

	//------------ Настраиваем  память (W5100) для Сокета 0 -------------
	SetW5100register(RMSR, 0x55);   // настраиваем RX буфер: по 2КБ под каждый сокет 
	S0_RX_BASE = 0x6000;     //  базовый адрес RX  буфера    для Сокета0
	S0_RX_MASK = 0x07FF ;   // (2048 -1 )= 0x07FF, RX Маска ( = длина_буфера – 1 )
	SetW5100register(TMSR, 0x55);   // настраиваем ТX буфер: по 2КБ под каждый сокет 
	S0_TX_BASE = 0x4000;  // базовый адрес TX буфера  для Сокета0
	S0_TX_MASK = 0x07FF;  // (2048 -1 )= 0x07FF, ТХ Маска ( = длина_буфера – 1 )

	//------------ прописываем свой МАС адрес   --------------
	//  т.е.  просто закидываем в МАС регистры W5100 
	//    – свои переменные  с определенными ранее величинами
	SetW5100register(SHAR0, MAC0);  
	SetW5100register(SHAR1, MAC1); 
	SetW5100register(SHAR2, MAC2);
	SetW5100register(SHAR3, MAC3);
	SetW5100register(SHAR4, MAC4);
	SetW5100register(SHAR5, MAC5);
		
	//------------  прописываем свой  IP  --------------
	// так же -  раскидываем в регистры W5100 – свои переменные
	SetW5100register(SIPR0, SERVER_IP0);
	SetW5100register(SIPR1, SERVER_IP1);
	SetW5100register(SIPR2, SERVER_IP2);
	SetW5100register(SIPR3, SERVER_IP3);
	 
	//------------  прописываем свой PORT  --------------
	// так же – свои константы – в регистры
	SetW5100register(S0_PORT0, SERVER_PORT0);
	SetW5100register(S0_PORT1, SERVER_PORT1); 

	//------------ прописываем  Gateway addr  --------------
	// так же – свои константы – в регистры
	SetW5100register(GAR0, GATEWAY_IP0); 
	SetW5100register(GAR1, GATEWAY_IP1); 
	SetW5100register(GAR2, GATEWAY_IP2); 
	SetW5100register(GAR3, GATEWAY_IP3); 

	//------------ set Subnet Mask  --------------
	SetW5100register(SUBR0, SUBNET_MASK0); 
	SetW5100register(SUBR1, SUBNET_MASK1); 
	SetW5100register(SUBR2, SUBNET_MASK2); 
	SetW5100register(SUBR3, SUBNET_MASK3); 
	char message_init[] = "W5100web_init\r\n";
	uprintf(message_init);
	// для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
}

//--------------------------------------------------------------
//-------------  ОТКРЫТИЕ СОКЕТА 0  ----------------------------
int Open_Socket0(void)
{
	// для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
	char message_open_1[] = "TRY\r\n";
	uprintf(message_open_1);
	if (try ==255) try =0;
	else try++;
	char message_open_2[] = "Start Open Socket\r\n";
	uprintf(message_open_2);
						
	// устанавливаем Сокет – в режим ТСР, остальные опции отключаем 
	SetW5100register(S0_MR, 0x01);   

	// засылаем в регистр команд – команду ОТКРЫТЬ ( сокет)
	SetW5100register(S0_CR, OPEN);  

	// проверяем или сокет открылся успешно
	// * в режиме ТСР , по  «SOCK_INIT»  можно проверить или сокет открылся
	if (GetW5100register(S0_SR) != SOCK_INIT)  // проверяем STATUS регистр
		 {
				SetW5100register(S0_CR, CLOSE); // если не открылся то закрываем
				return 0 ;                //  и выходим с кодом 0
		 }
	return 1;     //открылся успешно.  Выходим с кодом 1
}




//--------------------------------------------------------------
//-------------  Переводим Сокет0 в режим  СЛУШАТЬ  ------------

int Listen_Socket0 (void)
{
	char message_list[] = "Sock opened. Go Listen\r\n";								
	uprintf(message_list); // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ


// засылаем в регистр команд команду перевода сокета в режим СЛУШАТЬ
// *СЛУШАТЬ – т.к. мы – Сервер, а инициатива  исходит от Клиента

SetW5100register(S0_CR, LISTEN);  


if ( GetW5100register(S0_SR) != SOCK_LISTEN)  //  проверяем  Регистр Состояния
 {
  SetW5100register(S0_CR, CLOSE); //  если сокет не вошел в режим СЛУШАТь
  return 0;                   // закрываем его и выходим с кодом 0   
 } 
 
return 1;               //  сокет в режиме СЛУШАТЬ,  выходим с  кодом 1
 
}


//--------------------------------------------------------------------------
//-------------   проверка Установлено  ли  соединение с  Сокетом0 ? --------
// * в смысле от клиента ( браузера)

int Socket0_Connection_Established(void)
{

// если W5100  получает от клиента запрос на соединение, он отсылает ему пакет 
// с  установленным флагом ACK и  изменяет свой статуст на SOCK_ESTABLISHED
// («соединение с сокетом установлено)
// Проверить это можно либо  проверкой бита в регистре прерываний, 
// либо как здесь -  проверкой  регистра состояния


if  ( GetW5100register(S0_SR) == SOCK_ESTABLISHED)  return 1 ;

// читаем Регистр Состояния.  
// Если  комбинация битов (код) = «SOCK_ESTABLISHED» то выходим с 1

else return 0;     // если нет – выходим с кодом 0

	char message_estab[] = "Connection Established\r\n";
	uprintf(message_estab);
                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ


// *после того как соединение установлено,  сокет готов к приему/передаче данных

}



//----    проверка были ли приняты ДАННЫЕ -------------
//-----------------------------------------------------

// * «служебные» пакеты между сторонами  соединения могут и пересылаться
// но нас интересует были ли в них именно ДАННЫЕ
//  (например, запрос  страницы/файла  с веб-сервера)


int Socket0_Received_Data_Size (void)  

// на самом деле  интересует   размер принятых данных = НОЛЬ или нет

{

S0_RX_RSR = make16 (GetW5100register(S0_RX_RSR0), GetW5100register(S0_RX_RSR1) );  
// читаем два  8-битных регистра размера принятых данных 
// RSR0 – старш байт, RSR1 – младш байт
// и «собираем» 16-битное слово -  размер принятых данных


                uprintf("Received Data size is: %Lu (bytes) \r\n");
                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

if (S0_RX_RSR == 0 ) return 0;   // нет ДАННЫХ ( т.е. размер=0 )
                                     // выходим с кодом 0

else  return 1;    // размер данных не нулевой ( т.е. данные  -есть)
                      // выходим с кодом 1



}

//---------- вывод на терминал принятых ДАННЫХ ---------------
//------------------------------------------------------------
// * функция  полезна только при отладке.  Ее МОЖНО УДАЛИТЬ

void Socket0_Received_Data_Reading (void) 
{
	uint16_t n; 
	int RXbyte;

	S0_RX_OFFSET = make16 ( GetW5100register(S0_RX_RD0), GetW5100register(S0_RX_RD1) );  
// из двух  8-разрядных регистров  склеиваем  16 разрядную переменную -
// УКАЗАТЕЛЬ на  начало  принятых данных в RX буфере  сокета0

  uprintf("S0_RX_RD (RX mem read pointer)\r\n");
	
  S0_RX_OFFSET = (S0_RX_OFFSET & S0_RX_MASK ) ;
 // отсекаем лишнее  чтобы  укладывался в размеры выделенного под Сокет0 буфера

                 uprintf("> S0_RX_Offset = S0_RX_RD & S0_RX_MASK = %LX \r\n\r\n");
    

  S0_RX_Start_Addr = S0_RX_OFFSET + S0_RX_BASE ;

//вычисляем ФИЗИЧЕСКИЙ адрес начала  области памяти хранящей принятые данные


                 uprintf("> S0_RX_Start_Addr = S0_RX_OFFSET + S0_RX_BASE = %LX (physical)\r\n\r\n");
 

                  uprintf(">  Going  to print-out Received Data... \r\n\r\n");
                  uprintf("ooooooooooooooooooooooooooooooooooooooooooo\r\n");


for (n=0; n < S0_RX_RSR ; n++)   
 {
  
   if ( S0_RX_Start_Addr > (S0_RX_BASE + S0_RX_MASK)  )  S0_RX_Start_Addr = S0_RX_BASE;

   RXbyte = GetW5100register(S0_RX_Start_Addr);
  
  
                   uprintf("%c");

   S0_RX_Start_Addr++;
 
 }

                   uprintf("END of  received data oooooooooooooo\r\n\r\n");
                   
 
}


// --- проверяем или от Клиента пришел запрос на INDEX.HTML  файл ------
//----------------------------------------------------------------------

int Socket0_Received_Request_is_index_html(void)  
{
int RXbyte=0;

 S0_RX_OFFSET = make16 ( GetW5100register(S0_RX_RD0), GetW5100register(S0_RX_RD1) );  
// из двух  8-разрядных регистров  склеиваем  16 разрядную переменную -
// УКАЗАТЕЛЬ на  начало  принятых данных в RX буфере  сокета0


 

 S0_RX_OFFSET = (S0_RX_OFFSET & S0_RX_MASK ) ;
// отсекаем лишнее  чтобы  укладывался в размеры выделенного под Сокет0 буфера

 
 S0_RX_Start_Addr = S0_RX_OFFSET + S0_RX_BASE ;  
//вычисляем ФИЗИЧЕСКИЙ адрес начала  области памяти хранящей принятые данные

  
 
 
                uprintf("\r\n>----------- parsing HTTP header-------------\r\n");
                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

 
 while (RXbyte != 0x2F)   // ищем первый  "/"  в HTTP  заголовке
 {
  
    if ( S0_RX_Start_Addr > (S0_RX_BASE + S0_RX_MASK)  )  S0_RX_Start_Addr = S0_RX_BASE;
// начало блока данных не обязательно м располагаться в начале  буфера
// проверяем, не дошли  ли до КОНЦА  буфера
// если да – идем в самое НАЧАЛО буфера – данный продолжаются именно с того места

   RXbyte = GetW5100register(S0_RX_Start_Addr);  
// читаем из буфера RX байт,  на который  указывает СтартовыйАДрес
  
  
                      uprintf("%c");
                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ


   S0_RX_Start_Addr++;  // инкрементируем Адрес – теперь он указывает на следующ юайт
 
 }
 
// раз мы здесь значит уже дошли («отловили») до первого в HTTP заголовке символа “/”
// и сейчас Адрес  указывает на следующий за "/"  символ.  
// Ради него и затевался весь сыр-бор

    RXbyte = GetW5100register(S0_RX_Start_Addr); //считываем этот  символ
 
 
 
          uprintf("\r\n> -------- END of parsing HTTP header -------\r\n");
                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ


 
     if (RXbyte == 0x20)  return 1;  
// если это «пробел»  - значит клиент запрашивает файл без названия, тоесть index.html
//  выходим с кодом подтверждения 1

     else return 0;                
// если это был не пробел а любой другой символ, значит  запрашивается НЕ index.html
// выходим с кодом ошибки - 0

}





//------   отправка Клиенту страницы «ошибка 404» ------------
//-------------------------------------------------------------

// заполняем ТХ буфер сокета0  блоком данных из HTTP заголовка и   HTML  кода
//  страницы «ошибка 404»,  затем  показываем W5100  начало и конец 
// этого блока данных в буфере,  и даем команду  ОТОСЛАТЬ

void Socket0_Send_404_error (void) 
{   uint16_t n;
char TXbyte;
uint16_t datalength;



  S0_TX_OFFSET = make16 ( GetW5100register(S0_TX_RD0), GetW5100register(S0_TX_RD1) );  // из двух  8-разрядных регистров  склеиваем  16 разрядную переменную - УКАЗАТЕЛЬ 
// на  место, откуда можно начать размещать блок данных в ТX буфере  сокета0
  
  
  S0_TX_OFFSET = (S0_TX_OFFSET & S0_TX_MASK ) ;
// отсекаем лишнее  чтобы  укладывался в размеры выделенного под Сокет0 буфера
  
  
  S0_TX_Start_Addr = S0_TX_OFFSET + S0_TX_BASE ;
//вычисляем ФИЗИЧЕСКИЙ начальный адрес для размещения блока данных в буфере ТХ
  

  //вычисляем ДЛИНУ строки  содержащей HTTP заголовки и HTML  коды
  datalength=0;
  while ( ERROR404[datalength] !=0) datalength++;  
// попросту  инкрементируем «datalength» пока не наткнемся на первый 0х00 в строке
//  (0х00 -  признак конца данных)
 
 


// Для того, чтобы W5100 передала блок Данных, его необходимо разместить 
// в ТХ буфере Сокета, начиная с адреса, который ммы вычислили ранее.
// После этого, W5100 необходимо указать   КОНЕЦ блока данных в буфере.

// Указание на конец нашего блока данных мы записываем в соотв регистр W5100:


// Вытаскиваем из пары регистров - указателей конца блока данных их текущее значение
// и склеиваем из них  2-байтный указатель
// *( в отличие от предыдущего  вычисления ФИЗИЧЕСКОГО адреса начала длока данных
// здесь мы имеем дело именно с «внутренним» указателем адреса)
  S0_TX_End_Addr = make16 ( GetW5100register(S0_TX_WR0), GetW5100register(S0_TX_WR1) );  

// добавляем к получившемуся -  вычисленную ранее длину нашего блока данных
      S0_TX_End_Addr += datalength ;      // increment to  fatalength
   // получившееся  значение ( указатель на конец наших данных) вновь «расклеииваем» 
   // на  2 байта и  записываем в  соотв  регистры   
      SetW5100register(S0_TX_WR0, make8( S0_TX_End_Addr ,1) );  // старший байт 
      SetW5100register(S0_TX_WR1, make8( S0_TX_End_Addr,0) );  // младший байт
 
      
                 uprintf("\r\n>Data length is: %Lu \r\n");
                 uprintf("\r\n>--- Filling TX buffer  w  data: -----------\r\n");
                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
      
      
 // теперь приступаем к собственно заполнению  буфера ТХ – нашими  данными
for (n=0; n < datalength; n++)  // цикл  на длину блока данных
  {
     TXbyte = ERROR404[n];  
// читаем текущий байт из строки,  в которой записан весь код «веб страницы»
// ( HTTP заголовки и  HTML коды)
 

// поскольку «выданный» нам от W5100  адрес начала блока данных в ТХ буфере  
// может не совпадать с  началом  буфера, а  находиться, например в 10 байтах
// от конца буфера, необходимо при записи каждого нового байта наших данных
// проверять, не вылезли  ли  мы за границы буфера
 
  if (S0_TX_Start_Addr  > (S0_TX_BASE + S0_TX_MASK)) S0_TX_Start_Addr = S0_TX_BASE;
 // .. и если  дошли до края буфера – то   продолжать следует с НАЧАЛА буфера

// * W5100  в курсе этих манипуляций (это  вообще была  ее  идея а не наша ))и когда //будет передавать данные  - также, в  случае, когда дойдет до конца буфера  
//( именно БУФЕРА,  а НЕ до указателя на КОНЕЦ Данных) – также будет продолжать
//  от начала буфера
 

 // с ТЕКУЩИМ адресом  записи текущего байта мы разобрались выше 
// и сейчас просто пишем текущий байт данных – в  соотв  ячейку памяти буфера ТХ 
  SetW5100register( S0_TX_Start_Addr, TXbyte ) ;   
  
               
                       //putc(TXbyte);   
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

  S0_TX_Start_Addr++ ;
  // инкрементируем текущий адрес (для записи следующего байта данных)
  
  }     
      
                  uprintf("\r\n>--- end of  Filling  -----------\r\n");
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

// все, все данные для передачи мы разместили в буфере, 
// указали, где наши данные заканчиваются, теперь можно их и передавать    
  
    //  засылаем в Регистр Команд сокета  - команду SEND  
    SetW5100register(S0_CR, SEND);       
      
                    uprintf("> Data was  sent \r\n\r\n");
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

}


//-----------------------------------------------------------

//-- отправка Клиенту страницы «index.html» ---------------
//-------------------------------------------------------------------
void Socket0_Send_index_html (void) // send index.html "page"  index.html
{
// расписывать не стану – все абсолютно так же как при посылке страницы «ошибка 404»
// только  «строка»  содержащая  HTTP  заголовки и  HTML  коды – другая

	uint16_t n;
	char TXbyte;
	uint16_t datalength;
	
	char count_string[10] = "";
	sprintf(count_string, "%d", main_count);
	char INDEX[222]  = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Lenght: 43\r\n\r\n<HTML><meta http-equiv='refresh' content='2'/><CENTER>Passes: ";
	strcat (INDEX, count_string);
	strcat (INDEX, "</CENTER></HTML>");
	//char INDEX[222]  = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Lenght: 43\r\n\r\n<HTML><meta http-equiv='refresh' content='5'/><CENTER>Passes: " + "</CENTER></HTML>";
// символы для  создания  странички «index.html”

	uprintf("going to send INDEX.HTML.....\r\n");
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

  S0_TX_OFFSET = make16 ( GetW5100register(S0_TX_RD0), GetW5100register(S0_TX_RD1) );  // склеиваем  2-байтный указатель на началь адрес для размещения блока данных
  
  
  S0_TX_OFFSET = (S0_TX_OFFSET & S0_TX_MASK ) ;
  
  
  S0_TX_Start_Addr = S0_TX_OFFSET + S0_TX_BASE ;
  // вычисляем ФИЗИЧЕСКИЙ  начальный адрес  для размещения блока данных

	uprintf("\r\n  INDEX[i], datalegth -------------\r\n");
      
  //вычисляем ДЛИНУ блока данных
  datalength=0;

  while ( INDEX[datalength] !=0) datalength++; 
 // считаем длину данных – пока не дойдем до первого  0х00 – признака конца данных      

// записываем в  W5100  УКАЗАТЕЛЬ  на КОНЕЦ блока данных на передачу
 S0_TX_End_Addr = make16 ( GetW5100register(S0_TX_WR0), GetW5100register(S0_TX_WR1) );  // «склеиваем» вместе 2 байта текущего  значения

      S0_TX_End_Addr += datalength ;      // increment to  fatalength
      // добавляем длину нашего блока данных

 // новое значение заново распихиваем по двум 1-байтным регистрам     
      SetW5100register(S0_TX_WR0, make8( S0_TX_End_Addr ,1) );  // старш байт
      SetW5100register(S0_TX_WR1, make8( S0_TX_End_Addr,0) );  // младш байт

                 
                  uprintf("\r\n>Data length is: %Lu \r\n");
                  uprintf("\r\n>--- Filling TX buffer  w  data: -----------\r\n");
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
           
      
 // заполняем буфер – нашими данными на передачу
for (n=0; n < datalength; n++)
  {
   TXbyte= INDEX[n]; 
// читаем текущий байт из строки  содержащей «веб страницу»  index.html
// (т.е.   HTTP Header  + HTML code)
  
  if (S0_TX_Start_Addr  > (S0_TX_BASE + S0_TX_MASK)) S0_TX_Start_Addr = S0_TX_BASE;
  // проверяем не дошли ли до края буфера, и если да – перескакиваем на начало
  
  SetW5100register( S0_TX_Start_Addr, TXbyte ) ;  
   // зарисываем текущий байт блока данных ( «веб страницы») – в  буфер ТХ 
  

                //putc(TXbyte);  // printout to Terminal ( for testing purpose)
                      // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
   
  S0_TX_Start_Addr++ ;
  // переходим к следующему адресу ТХ буфера
  
  }     
      
                 uprintf("\r\n>--- end of  Filling  -----------\r\n");
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
    
  // буфер заполнен нашим блоком данных, можно их передавать Клиенту

    //  пишем в Регистр Команд сокета - команду SEND  
    SetW5100register(S0_CR, SEND);       
      
                     uprintf("> Data was  sent \r\n\r\n");
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

}

//--------------------------------------------------------

 

//--- содержит ли пакет, пришедший от Клиента,  установленный флаг FIN ? ------
//-----------------------------------------------------------------------------

int Socket0_FIN_Received(void)
{ 
// проверяем  не пожелал ли  клиент разрыва отношений (тоесть соединения)
// послав нам  флаг FIN  -  запрос на разрыв соединения

// можно проверять через проверку бита в регистре прерываний
// либо как здесь – через проверку  Регистра Состояния Сокета0


// выходим с  1  если  FIN пришел  и  с 0  если  FINа не было
if ( GetW5100register(S0_SR) == SOCK_CLOSE_WAIT) return 1;
else return 0;

}


//---------------------------------------------------------


 
// ------ разрываем СОЕДИНЕНИЕ для  Socket0   -----------------
//-------------------------------------------------------------
void Socket0_Disconnect(void)
{


//  отключаем сокет от СОЕДИНЕНИЯ с клиентом
// заслав соотв команду в Регистр Команд  сокета0

SetW5100register(S0_CR, DISCON);

}





// ------  проверка или Сокет0 ЗАКРЫТ --------------------
//--------------------------------------------------------
int Socket0_Closed(void)
{
// Сокет мож быть закрыт после засылки нами в Регистр Команд Сокета
//  команды ЗАКРЫТь (CLOSE), или  после тайм-аута, или  при разрыве соединения

// проверка или  Сокет0 действительно закрыт

// * можно делать через проверку  бита в регистре прерываний,
// либо как здесь -  проверкой Регистра Состояния
 

if  ( GetW5100register(S0_SR) == SOCK_CLOSED) return 1;
else return 0;
// выходим с 1  если Сокет (или СОЕДИНЕНИЕ сокета0) закрыто
// либо с 0 если сокет  до сих пор не закрылся


}





 
// -----  нет ли ТАЙМ-АУТа по соединению Сокета0 ? ------------
//-------------------------------------------------------------

int Socket0_Connection_Timeout(void)
{
// если на линии ошибки, или  клиент хочет закрыть соединение, или  от клиента давно
// ничего не приходит   итп – проверяем соединение на тайм-аут
//  иначе будет некорректно,  если наш  сервер будет слать клиенту пакеты
// ( с  соответствующими TCP флагами ) в том порядке, который подразумевается 
// для нормального процесса обмена пакетами


// тайм-аут проверяется либо через биты в  регистре прерываний
// либо как у нас – через проверку Регистра Состояния сокета0

// ПРИЕЧАНИЕ: как видим, регистр проверяется на состояние «SOCK_CLOSED»
// - какая тут связь с тайм-аутом??
// Дело в том что в Регистре Состояний нет отдельного кода для тайм-аут,
// но в W5100  код «SOCK_CLOSED»  связан также и  с тайм-аутом
// поэтому  проверка на этот код – вполне легитимна

if  ( GetW5100register(S0_SR) == SOCK_CLOSED) return 1;
else return 0;

// выходим с 1  если   тайм-аут  наступил, либо с 0 если тайм-аута не было

}



// ------------  ЗАКРЫТИЕ Сокета0    ----------------------------
//----------------------------------------------------------------


void Socket0_Closing(void)
{
//  should be performed in case that connection is closed after data exchange,
// socket should be closed with Timeout occurrence, 
// or forcible disconnection is necessary due to abnormal operation etc.
  

                    uprintf(">going to Close Socket0 ..... \r\n");
                      // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
           
// засылаем в Регистр Команд сокета0  код на ЗАКРЫТИЕ сокета
SetW5100register(S0_CR, CLOSE);


                   uprintf(">  ------ Socket CLOSED    ----- \r\n\r\n");
                      // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

}
 




// ---- ЗАПИСЬ (посылка) байта  через SPI   -------------
//--------------------------------------------------------


//* у меня название функции «SSPI» оттого, что в компайлере есть собственная 
// готовая йункция (SPI… )но она глючная. Поэтому я написал свой вариант 
// а чтоб не было конфликтов (названий) в компайлере – дал ей другое имя

// назначение функции – послать ОДИН БАЙТ через SPI   
//  более верхние уровни «протокола»  обмена (тоесть запись всех ТРЕХ байтов)  реализует 
//  другая функция  - функция для записи в РЕГИСТР

//* состояние линаа данных -  валидное для W5100 при  переходе клока из 0 в 1

void SSPI_write( int Data)
{
	HAL_SPI_Transmit (&hspi1, (uint8_t *)&Data, 1, 200);
//int i;
//int mask=0x80; // ставим маску на СТАРШИЙ бит (тоесть начинаем со СТАРШЕГО бита)
//                // так  как по  протоколу  SPI для W5100 данные следуют 
//                // от СТАРШЕГО бита -  к МЛАДШЕМУ  ( MSB first)


////output_low(SCK);   // просто чтоб быть уверенными что клок – в «исходном» положении

//for (i=0; i<8;i++)    // цикл для считывания 8 бит
// { 
//  //output_low(MOSI);   // просто выставляем «данные» на линии -  в 0 

//  if ( (mask & Data) != 0) output_high(MOSI);   
//          // если  (маска & ДАННЫЕ)  =1  то  выставляем на линию 1
//         // если нет – то на линии  так и остается 0, выставленный строчкой выше


//  output_high(SCK);   
//   // выдаем пульс клока ( из 0 в 1)  - именно по нему  происходит запись бита 
//   // с линии  данных SPI – в   регистры W5100
// 
//  mask = mask>>1; ;  // сдвигаем маску  на 1 бит вправо
//                    // *можно поставить  эту операцию и  после  цикла
//                    // но в этом месте этим заодно  обеспечивается 
//                    // некотор задержка между тактами (тоесть частота клока)

// 
//  output_low(SCK); // завершаем  клок, переводим его в «исходное» состояние ( 0 )
// }
// // «.. и так восэм  рас» (с)

}
//----------------------------------------------------------



//----------- ЧТЕНИЕ байта с линии   SPI  ------------------
//-----------------------------------------------------------


//* у меня название «SSPI» оттого, что в компайлере есть собственная 
// готовая йункция (SPI… )но она глючная. Поэтому я написал свой вариант 
// а чтоб не было конфликтов в компайлере – дал ей другое имя

// назначение функции – прочесть  ОДИН БАЙТ
//  более верхние уровни «протокола» реализует 
// собственно функция  чтения РЕГИСТРА

// *данные при чтении из регистров W5100 -  валидные при  переходе клока из 1 в 0

//* тоесть если при передаче  мы  сначала  выставляли данные на линию
//  и только после этого  подтверждали их валидность переводом клока из 0 в 1
// а  на прниеме  мы сначала  выставляем  клок в 1,  читаем данные
// и «защелкиваем» данные  переходом клока из 1 в 0


uint8_t SSPI_read ( void)
{
	
int Data=0;
	
HAL_SPI_Receive (&hspi1, (uint8_t *)&Data, 1, 200);
	
//int i;
//int mask=0x80; // ставим маску на СТАРШИЙ бит (тоесть начинаем со старшего бита)
//                // так  как по  протоколу  SPI для W5100 данные следуют 
//                // от СТАРШЕГО бита -  к МЛАДШЕМУ  ( MSB first)


////output_low(SCK);   // просто чтоб быть уверенными что клок – в «исходном» положении

//for (i=0; i<8;i++)  // цикл для считывания 8 бит

// { 
//  output_high(SCK);   // выдаем пульс клока ( из 0 в 1)      
//    
//  if ( input(MISO)!= 0) Data = Data | mask ; 
//  // если на линии 1, то  делаем ИЛИ  маски – и текущего  значения «собираемого» байта
//  
//  mask = mask>>1; ;   // сдвигаем маску  на 1 бит вправо
//                    // *можно поставить и  после  цикла
//                    // но в этом месте этим заодно  обеспечивается 
//                    // некотор задержка между тактами (тоесть частота клока)

//  
//  output_low(SCK); // завершаем  клок, переводим его в «исходное» состояние ( 0 )

// }

return Data;
}
//---------------------------------------------------------------



//-------  ЗАПИСЬ  ( установка)  регистров W5100 -------------
//--------------------------------------------------------------
void SetW5100register (uint16_t regaddr, uint8_t data)
// 2 аргумента: 16 бит адреса регистра и 8 бит данных для записи

{
output_low(SS); // выставляем Чип Селект ( ставим в 0)

SSPI_write (0xF0);  // сперва  посылаем в регистр команду ЗАПИСЬ

                                   //*  make8 – преобразует 16 бит - в  8 бит
SSPI_write (  make8(regaddr,1) );  // выделяем из адреса старший байт  (MSB)
                                   // и пишем  его на SPI     


SSPI_write (  make8(regaddr,0) );  // выделяем из адреса младший байт  (LSB)
                                   // и шлем  его на SPI  

SSPI_write (data);   // пишем на SPI ДАННЫЕ для записи в регистр 


output_high(SS);     //  снимаем ЧипСелект  ( ставим в 1)

}
//---------------------------------------------------------




//-----  ЧТЕНИЕ содержимого регистров W5100 ----------
//----------------------------------------------------
int  GetW5100register (uint16_t regaddr)
//аргумент – 2-байтовый адрес регистра
// возвращает: 1 байт считанных из регистра данных
{
int RegData;

output_low(SS); // выставляем Чип Селект ( ставим в 0)


SSPI_write (0x0F);  // сперва  засылаем команду ЧТЕНИЕ

                                   //*  make8 – преобразует 16 бит в  8 бит
SSPI_write (  make8(regaddr,1) );  //  выделяем из адреса старший байт  (MSB)
                                   // и выставляем его на SPI     

SSPI_write (  make8(regaddr,0) );  //  выделяем из адреса младший байт  (LSB)
                                   // и выставляем его на SPI  

RegData = SSPI_read ();    // теперь в ответ W5100  выдаст нам содержимое (8 бит) 
                           // регистра по засланному перед этим адресу


output_high(SS);    //  снимаем ЧипСелект  ( ставим в 1)

return RegData;	// выходим с  прочитанным байтом

}


void output_high (uint16_t pin){
	HAL_GPIO_WritePin(GPIOA, pin, GPIO_PIN_SET);
}

void output_low (uint16_t pin){
	HAL_GPIO_WritePin(GPIOA, pin, GPIO_PIN_RESET);
}

uint8_t make8(uint16_t n, uint8_t high){
	if (high == 1) return ((n & 0xFF00) >> 8);
	else return (n & 0xFF);
}

uint16_t make16(uint8_t high, uint8_t low){
	return ((high<<8) | (low));

}

/* USER CODE END 4 */

#ifdef USE_FULL_ASSERT

/**
   * @brief Reports the name of the source file and the source line number
   * where the assert_param error has occurred.
   * @param file: pointer to the source file name
   * @param line: assert_param error line source number
   * @retval None
   */
void assert_failed(uint8_t* file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
    ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */

}

#endif

/**
  * @}
  */ 

/**
  * @}
*/ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
